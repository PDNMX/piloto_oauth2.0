SISTEMA DE AUTORIZACIÓN OAUTH 2.0

# Introducción

El presente documento describe los mecanismos de interconexión para los Sistemas 2 (S2) y 3 (S3) con la Plataforma Digital Nacional (PDN) en un ambiente de pruebas. Esta información es proporcionada a los equipos técnicos de las Secretarías Ejecutivas de los Sistemas Locales Anticorrupción (SESLAs) y Secretaría Ejecutiva de los Sistemas Nacionales Anticorrupción (SESNA) para la implementación de estos mecanismos, con datos sintéticos, en tres estados pilotos (Chihuahua, Jalisco y Oaxaca).

## Propósito

El propósito de este documento es proporcionar toda la información relevante con respecto a la implementación del mecanismo de autorización Oauth 2.0 utilizado en esta solución para el cliente.

## Historial de Revisiones

| **Revisión** | **Autor** | **Fecha** | **Razón del cambio** |
| --- | --- | --- | --- |
| PA1 | E. Camargo | 21-Jul-2020 | Primera revisión del documento |
| A | H. Rodríguez | 24-Jul-2020 | Documento aprobado |


# Especificaciones técnicas


## Ejecución del programa

- El servicio del servidor de autorización OAuth 2.0 deberá descargarlo del repositorio de Github de la PDN del siguiente link, siguiendo las instrucciones que ahí se especifican...

[https://github.com/PDNMX/piloto\_oauth2.0](https://github.com/PDNMX/piloto_oauth2.0)

- Para clonar el repositorio desde el CLI de su computador utilice el siguiente comando:

$ git clone https://github.com/PDNMX/piloto\_oauth2.0.git

- Se le solicitará su usuario y contraseña de Github para acceder.

- Deberá colocar nuestro Dockerfile dentro de la carpeta de nuestro proyecto

```sh
FROM node:12
ADD . /oauth20
WORKDIR /oauth20
 
RUN yarn add global yarn \
&& yarn install \
&& yarn cache clean
 
EXPOSE 9003
CMD ["yarn", "start"]

```



- Se requiere modificar el archivo _package.json_ y sustituir el campo scripts por el siguiente código

```javascript
"scripts": {
 "test": "echo \"Error: no test specified\" && exit 1",
 "dev": "nodemon node AuthorizationServer.js",
 "start": "node AuthorizationServer.js"
}
```

- Modificar el archivo package.json en la sección de scripts como se indica a continuación

{

&quot;name&quot;: &quot;api-del-registro-de-servidores-p-blicos-de-la-administraci-n-p-blica-federal-que-intervienen-en-procedimientos-de-contrataciones-p-blicas&quot;,

&quot;description&quot;: &quot;No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)&quot;,

&quot;main&quot;: &quot;index.js&quot;,

&quot;scripts&quot;: {

&quot;dev&quot;: &quot;nodemon node index.js&quot;,

&quot;start&quot;: &quot;node index.js&quot;

},

&quot;keywords&quot;: [

&quot;swagger&quot;

],

&quot;license&quot;: &quot;Unlicense&quot;,

&quot;private&quot;: true,

&quot;dependencies&quot;: {

&quot;connect&quot;: &quot;^3.2.0&quot;,

&quot;js-yaml&quot;: &quot;^3.3.0&quot;,

&quot;oas3-tools&quot;: &quot;^2.0.2&quot;

}

}

- Agregaremos un nuevo servicio al archivo docker-compose.yml en la carpeta designada para mongodb de la siguiente forma…

```sh
..

Oauth20:

restart: always

container_name: s2

build:

context: ../oauth20/

dockerfile: Dockerfile

ports:

- 9003:9003

links:

- mongo

depends_on:

- mongo

..
```

El puerto incluye el mapeo del puerto en el host con el puerto interno en el contenedor \&lt;host\&gt;:\&lt;contenedor\&gt;, el puerto interno deberá coincidir con el puerto especificado dentro del código de nodejs, en este caso usaremos 9003.

- Deberemos asegurarnos que el puerto en el host no esté bloqueado por el firewall del sistema operativo y abrirlo en caso de ser necesario,dado que el servicio deberá ser expuesto al exterior para su consumo

- Una vez hecho esto procedemos correr el docker compose desde la carpeta de mongoDB que contiene el archivo docker-compose.yml de la siguiente forma

$ docker-compose up -d

En caso que mongoDB ya esté corriendo en un contenedor, solo construirá la nueva imagen y se creará el nuevo contenedor para oauth20

- Una vez terminado el proceso verificaremos que todos los contenedores dentro del archivo docker-compose.yml estén corriendo con el comando

$ docker-compose ps


## Variables de entorno

El nombre de la base de datos, parametros de configuracion y los nombres de las colecciones son configurables desde el archivo config.env_ **,** _ localizado en la carpeta config

A continuación listamos las variables y su uso

**USERMONGO** : Usuario para acceder a la base de datos (verificar que el usuario tenga los privilegios correspondientes )

**PASSWORDMONGO** : Password para acceder a la base de datos

**HOSTMONGO:** Dirección ip donde se encuentra alojada la base de datos

**DATABASE** : Nombre de la base de datos

Las variables de entorno que hacen referencia a nuestros tokens

**EXT** : Expiración del token en segundos

**RTEXT** : Expiración del refresh token en segundos

**SEED** : Semilla para la codificación del JWT

Cabe mencionar que el **refresh token** es un String aleatorio no un JWT, ya que el refresh token lo validamos en el servidor de autenticación. Por lo tanto, podemos obtener haciendo una petición a la base de datos y verificando los parámetros para generar un nuevo token.

  1.
## Esquemas en la base de datos

Dentro de MongoDb tendremos una base de datos específica para las colecciones que conciernen a la implementación oauth2.0

Usuarios

Nombre de la colección: **users**

| **Nombre del campo** | **Tipo** | **Valor posible** | **Descripción** |
| --- | --- | --- | --- |
| username | String | &#39;ecamargo&#39; | Nombre del usuario o identificador |
| password | String | &#39;123456&#39; | Contraseña del usuario |
| scope | Array String | [&#39;write&#39; , &#39;read&#39;] | Privilegios a los cuales se asocia este usuario |

Clientes

Nombre de la colección: **clients**

| **Nombre del campo** | **Tipo** | **Valor posible** | **Descripción** |
| --- | --- | --- | --- |
| clientId | String | &#39;pdn.resource.1&#39; | Identificador del cliente |
| clientSecret | String | &#39;password&#39; | Contraseña del cliente |
| grants | Array String | [&#39;admin&#39;] | Privilegios asociados con el cliente |

**Nota:** En caso de que el valor clientSecret no se agregue al documento, porque no existe en el ambiente, la solicitud post no deberá contener dicho parámetro o se puede colocar en el documento con un valor vacío, es decir, dos comillas simples &#39;&#39;

Tokens

Nombre de la colección: **tokens**

| **Nombre del campo** | **Tipo** | **Valor posible** | **Descripción** |
| --- | --- | --- | --- |
| access\_token | String | &#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImVjYW1hcmdvIiwianRpIjoiR1VoQ1dNR0siLCJzY29wZSI6IndyaXRlICIsImlhdCI6MTU5NTMwNDAwMiwiZXhwIjoxNTk1MzA0MDYyfQ.n5JLQo0fl7l0LbJ\_anPfsA3O2r-EMlGmvK0fJ-LP2Zg&#39; | Token en formato JWT el cual permite la validación de identidad en el recurso protegido |
| expires\_in | Number | 300 | Tiempo de expiración del access\_token en segundos |
| refreshToken | String | OztWyf5YGjPJxrkkx4feeRGT3eup21yRMZgfMuNLrwBKvsIcKT3u6PvyjGlfc951nLhr0tNOZT4UezG971FXUNBaUNDaWNO6h8Uzno62wJA5K3iRF9smW4IdgmXMpkr4fB0C5KfQmsjNZL02bTzrQBmJ4BEOTmRjseAkr0A3JQU3vFtIyyXHQWxVaW03tNDgu001feEgQ15XilnmWq9zubngnnLLoZrN6bah3UhGxSwFgydgzR9W19CpxDdryrsE | Token (random string) el cual se utiliza para generar un nuevo token (flujo refresh token) |
| refresh\_token\_expires\_in | Number | 600 | Tiempo de expiración del refresh token en segundos |
| refresh\_token\_expires\_in\_date | Number | 1595275826 | unix timestamp de la expiracion del refresh token |
| client | Object | {clientId: &#39;pdn.resource.1&#39;} | Se almacena solo el id del cliente |
| user | Object | {username: &#39;ecamargo&#39;} | Se almacena el username |

  
## Obtención del token

Para poder generar un nuevo token se requiere mandar una solicitud de tipo POST a la ruta /oauth/token

Los parámetros se describen en el documento &quot;Guía de referencia protocolo de autorización&quot;, a continuación se describen algunas consideraciones.

- Los parámetros que se pueden mandar en el encabezado son el client\_id y el client\_secret. Estos tendrán que ir codificados en formato base 64 y anteponer la palabra **Basic** ya que la autenticación es de ese estilo y se obtiene el siguiente formato

Basic base64(client\_id:client\_secret)

En el siguiente enlace, se puede generar el formato y obtener el siguiente resultado [https://www.blitter.se/utils/basic-authentication-header-generator/](https://www.blitter.se/utils/basic-authentication-header-generator/)

Ejemplo: Basic dHhtLmdsb2JhbDpob2xh

También se pueden pasar esos dos parámetros dentro del body de la solicitud POST

El campo client\_secret por ser opcional puede ir o no dentro de cualquiera de las dos opciones proporcionadas anteriormente

- El _Content-Type_ tiene que ser _application/x-www-form-urlencoded_ para poder mandar los parámetros y obtener respuesta esperada

Colocar el comando curl para realizar una petición hacia el servidor de autenticación solo como ejemplo:

```sh
curl --location --request POST 'http://127.0.0.1:9003/oauth/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic dHhtLmdsb2JhbDo=' \
--data-urlencode 'grant_type=password' \
--data-urlencode 'username=ecamargo' \
--data-urlencode 'password=123456' \
--data-urlencode 'scope=read writeSuper'
```
  
## Scopes

Los scopes son privilegios que se relacionan directamente al usuario para restringir el nivel de acceso a los recursos protegidos (API).

Cuando se envía la solicitud POST, se pueden enviar los scopes solicitados por medio del parámetro **scope,** estos se validan en el servidor de autenticación y solamente se retornan los que estén asociados al usuario.

Debido a que los scopes son opcionales, o sea, no están definidos; esto queda fuera del alcance de la implementación OAUTH2. Se recomienda generar una colección con ellos y generar un método de asociación hacia los usuarios.

  
## Respuesta de la solicitud

```sh
{
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImVjYW1hcmdvIiwianRpIjoiVnduOW9qOXciLCJzY29wZSI6InJlYWQgIiwiaWF0IjoxNTk1NjIxNTk3LCJleHAiOjE1OTU2MjE2NTd9.ES5cQvNxOm--eTpxj73daxK6rZdCtrVQqs0ADjvjIFM",
    "token_type": "bearer",
    "expires_in": 600,
    "refreshToken": "4MuSJmBRnw93p1OfUysA05EDacJGPdsThtaZ4QSmjacR6GXx2ZJ2UtqxANmckS5v31o4KcRqCZDcTDeK8KruU6Xek0prSKO7KIPjBNfN6ipTwdaGX6pqdQ4HQ562v7m7WxZWo9gPc9WCVzKmsUqwgKxq46o4hrTfXeqHk8bVGcMRxvXdsHXFEntn4tA7YGJs5N71flqs3NeRneybLqmXRuEPC2UU2X48RagZU4MozJRL8WIS7p4f6Lpglx2pnpAx",
    "refresh_token_expires_in": 900,
    "scope": "read "
}
```

Los parámetros se describen en el documento &quot;Guía de referencia protocolo de autorización&quot;, a continuación se describen algunas consideraciones.

El parámetroaccess\_token es un JWT. Para mayor información, consulte el enlace [https://openwebinars.net/blog/que-es-json-web-token-y-como-funciona/](https://openwebinars.net/blog/que-es-json-web-token-y-como-funciona/)

Los JWT se generan con base en una semilla que es una cadena de texto la cual se usa para codificar el JWT y con esa semilla es posible validarlo en el servidor de recursos protegidos, es decir, en el API.

 De esta manera evitamos el uso de la base de datos para conceder el acceso a los recursos

El JWT generado almacena los siguientes parámetros en el payload, los cuales sirven para verificar si el token ha expirado (iat, exp), si el token tiene el privilegio para usar el recurso (scope) o si necesitamos ver quien genera la operación (username):

iat : tiempo de creación del token

exp: tiempo de expiración del token

scope: privilegios solicitados del usuario

username: nombre del usuario

jti: hace único al JWT (para evitar duplicados )


# Transferencia de conocimiento

  
## Tecnologías utilizadas

- NodeJS v12.18.2
- MongoDB 4.2.8

Se requiere que los documentos de clientes y usuarios estén previamente generados. Se puede acceder a la base de datos y generar el documento, la estructura ya se encuentra disponible en la sección[_ **2.3 Esquemas en la base de datos** _](#_dsldk0afh95n)

El archivo que contiene la lógica del servidor es AuthorizationServer.js. De este archivo se listan las funcionalidades y se desglosa cada punto en las secciones posteriores.

Para poder acceder a la base de datos se tiene el siguiente fragmento de código:


```javascript
//connection mongo db
const db = mongoose.connect('mongodb://'+process.env.USERMONGO+':'+process.env.PASSWORDMONGO+'@'+process.env.HOSTMONGO+'/'+process.env.DATABASE, { useNewUrlParser: true,  useUnifiedTopology: true  })
   .then(() => console.log('Connect to MongoDB..'))
   .catch(err => console.error('Could not connect to MongoDB..', err))
```
## Funciones utilizadas

La función createToken genera el token que se ingresara a la base de datos. Como parámetros de entrada tenemos el clientId , username y los scopes, los cuales se obtienen de solicitudes hacia la base de datos previamente a la llamada de la función.

```javascript
function createToken(clientId,username, scope){
   let expiresin = Number(process.env.EXT); //se obtienen los segundos de vida del token

   let access_token = jwt.sign({
       username: username,
       jti: randomstring.generate(8),
       scope : scope
   },process.env.SEED,{expiresIn : expiresin }); //se genera el JWT y se se agregan a su payload algunos atributos que consideramos se utilizaran en el API

   var tokenResponse = {
       access_token: access_token,
       token_type: 'bearer',
       expires_in: expiresin, //value in seconds
       refreshToken: randtoken.uid(256),
       refresh_token_expires_in: Number(process.env.RTEXT) , //value in seconds
       refresh_token_expires_in_date: Math.floor(Date.now() / 1000) + Number(process.env.RTEXT) ,
       scope: scope,
       client: {clientId: clientId},
       user: {username : username}
   }
   return tokenResponse;
}

```
En el código, se obtiene la expiración del token y posteriormente, se genera el JWT. Aquí se observa que solicitamos variables de entorno relacionadas con el token como el **SEED** ylos tiempos de expiración.

Una vez creado el JWT se agrega como valor al campo access\_token,se llenan los demás campos con los parámetros en entrada de la función y otros se generan en tiempo de ejecución, como lo es el refreshToken que es un random String. Para este último se usa la librería rand-token para generarlo y retornar el objeto.

Para mayor información de la librería rand-token, consulte el siguiente enlace: [https://www.npmjs.com/package/rand-token](https://www.npmjs.com/package/rand-token)

La función decodeClientCredentials lo que realiza es tomar el objeto _&quot;req&quot;,_ que es la solicitud que llega de algún ente externo al servidor, y busca si los parámetros client\_Id y client\_secret se enviaron dentro del header de la solicitud o si se enviaron como parámetros del body. Se extraen de cualquiera de los dos casos y se devuelven.
 Como el client\_secret es opcional, se inicializa como un string vacío el cual más adelante se usará para validar si existe o no un valor en client\_secret en la base de datos.


```javascript
var decodeClientCredentials = function(req) {

   var clientId;
   var clientSecret ='';

   if (!req.headers.authorization || req.headers.authorization.indexOf('Basic ') === -1) {
       //check the body
       if(req.body.client_Id){
           clientId = req.body.client_Id;
           if(req.body.client_secret){
               clientSecret = req.body.client_secret;
           }
       }
   }else{
       const base64Credentials =  req.headers.authorization.split(' ')[1];
       const credentials = Buffer.from(base64Credentials, 'base64').toString('ascii');
       [clientId, clientSecret] = credentials.split(':');
   }

   return { id: clientId, secret: clientSecret };
};

```
  
## Servicios MongoDB

También se exportan los servicios que son los que realizan las peticiones la base de datos:

var userService= require(&quot;./mongoUser&quot;);

var clientService = require(&quot;./mongoClient&quot;);

var tokenService = require(&quot;./mongoToken&quot;);

Cada uno de ellos se describe en las siguientes secciones.

    
### mongoUser

Dentro del archivo mongoUser se tienen las siguientes funciones:

- getUser(username, password). Este método devuelve el usuario correspondiente al username y el password recibidos en el método, en caso de que existan en la base de datos

- getUserByUsername(username).Este método devuelve el usuario correspondiente al username

    
### mongoClient

Dentro del archivo mongoClient se tienen las siguientes funciones:

```javascript
var clientModel = require('./mongo/model/client');

async function getClient (clientId){
   let client = await clientModel.findOne({clientId: clientId}).exec();
   return client;
}
module.exports.getClient = getClient;
```

- getClient (clientId)retorna el cliente correspondiente al parametro clientId pasado en la función

Como se puede observar, las funciones dentro de los &quot;servicios&quot; son de tipo _async_, esto porque los métodos que provee mongoose retornan un _promise._ Por lo tanto, cuando se invoquen las funciones de los servicios se tiene que anteponer la palabra _ **await** _.

Al final de los archivos de servicios se exportan las funciones para ser reconocidas a la hora de importarlos en el archivo principal.

    
### mongoToken

Por último, se tiene el archivo mongoToken donde se tienen las siguientes funciones:

- getTokenByRefresh (refresh\_token). Permite obtener el documento token por el campo refresh\_token, esto es usado en el flujo refresh token para la validación de los campos.

- removeTokenByRefresh (refresh\_token). Este método remueve el token dado el refresh\_token. Esta función se usa ya que se ha generado el nuevo token por el flujo refresh token. Se elimina la entidad ya que no debería ser funcional en ese punto del flujo

  1.
## Modelos y Esquemas

En la ruta piloto\_oauth2.0/mongo se encuentran los modelos y los esquemas generados con mongoose.

Los esquemas o &quot;_schemas_&quot; son la definición de la entidad, es decir, del documento. Dentro de cada schema se definen los campos y el tipo de dato de cada uno.

El modelo o &quot;_model_&quot; se genera con base al _schema_, y nos permite generar operaciones CRUD hacia la base de datos.

```javascript
var mongoose = require(‘mongoose’),
modelName = ‘client’,
schemaDefinition = require(’…/schema/’ + modelName),
schemaInstance = mongoose.Schema(schemaDefinition),
modelInstance = mongoose.model(modelName, schemaInstance);
module.exports = modelInstance;
```

En la figura anterior (/schema/client.js), el campo modelName es el nombre de la base de datos dentro de MongoDB, solo que para la creación del modelo en mongoose el nombre es singular y en la base de datos tiene que ser plural (clients). Esta rúbrica se describe en la documentación de mongoose.


## Lógica principal

La lógica principal se encuentra en la solicitud tipo post/oauth/token.Dentro de esta función se realizan las validaciones para la obtención del token, ya sea grant type password o refresh token. El orden de las validaciones es el siguiente:

**Método Grant type password**

1. Se obtienen los datos del cliente y se comprueban
2. Se obtiene el _grant type_ enviado en el _body_ de la solicitud y se comprueba que sea de tipo _password_
3. Se obtienen el username y el password del _body_ de la solicitud, con estos datos se solicita a la base de datos el documento de ese usuario asociado a esos campos
4. En caso de que el usuario exista, se obtienen los scopes enviados en el body de la solicitud
5. Se validan los scopes asociados al usuario
6. Se genera el token
7. El token se almacena en la base de datos
8. Se retorna la respuesta en el formato descrito en el documento _&quot;__Guía de referencia protocolo de autorización&quot;_

**Método Grant type refresh token**

1. Se obtienen los datos del cliente y se comprueban
2. Se obtiene el grant type enviado en el _body_ de la solicitud y se comprueba que sea de tipo _refresh\_token_
3. Se obtiene el token por medio del refresh token
4. Se valida que sea el mismo cliente el que manda la solicitud al que está asociado el token
5. Se valida la expiración del refresh token
6. Se obtienen el usuario por medio de la información asociada al token
7. En caso de que el usuario exista, se obtienen los scopes enviados en el _body_ de la solicitud
8. Se validan los scopes asociados al usuario
9. Se genera el token
10. El token se almacena en la base de datos
11. Se elimina el token asociado al refresh token
12. Se retorna la respuesta en el formato descrito en el documento _&quot;__Guía de referencia protocolo de autorización&quot;_

  
## Respuestas de error y causas

| **Mensaje de error** | **Status del error** | **causa** |
| --- | --- | --- |
| Invalid Authentication Credentials Client | 401 | Los parámetros del cliente no son correctos |
| client error auth | 401 | El client\_secret es incorrecto |
| unsupported\_response\_type | 401 | El grant type es incorrecto |
| Error refreshToken | 401 | El refresh token mandado no se encuentra en la bd |
| Invalid param refresh | 401 | No se mando el parámetro refresh\_token en el body de la solicitud |
| compromised token by client Id | 401 | El clientId enviado en la solicitud es diferente al que se tiene asociado al token |
| Invalid token | 401 | El refresh token expiró |
| Invalid Authentication Credentials user | 401 | Credenciales inválidas por parte del usuario |


# Glosario

| API | Application Program Interface |
| --- | --- |
| GOV UK | Embajada Británica |
| GCP | Google Cloud Platform |
| JSON | Formato de texto sencillo para el intercambio de datos |
| JWT | JSON Web Token es un estándar abierto basado en JSON propuesto por IETF (RFC 7519) para la creación de tokens de acceso |
| Oauth2.0 | Open Authorization es un estándar abierto que permite flujos simples de autorización para sitios web o aplicaciones informáticas |
| PDN | Plataforma Digital Nacional para combatir la corrupción |
| REST | Interfaz entre sistemas que use HTTP para obtener datos o generar operaciones sobre esos datos en todos los formatos, como XML y JSON |
| S2 | Sistema 2. Servidores públicos que intervienen en procedimientos de contratación |
| S3 | Sistema 3. Servidores públicos y particulares sancionados |
| S3.1 | Sistema 3 para los Servidores públicos sancionados únicamente |
| S3.2 | Sistema 3 para los Particulares sancionados únicamente |
| SESLA | Secretaría Ejecutiva de los Sistemas Locales Anticorrupción |
| SESNA | Secretaría Ejecutiva de los SIstemas Nacionales Anticorrupción |
| XML | Lenguaje que define los formatos aceptados que pueden utilizar los grupos para intercambiar información |


# Referencias

| **Ref.** | **Nombre del documento** | **Número del documento** |
| --- | --- | --- |
| 1 | [Guía de referencia protocolo de autorización](https://drive.google.com/file/d/17-npQleAV87gV19hbmtzgZipegl0qrIO/view) | - |
